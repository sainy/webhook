{
  "name": "coffee-resque",
  "version": "0.1.8",
  "description": "Coffeescript/Node.js port of Resque",
  "keywords": [
    "resque",
    "redis",
    "queue",
    "coffee script"
  ],
  "homepage": "https://github.com/technoweenie/coffee-resque",
  "author": {
    "name": "Rick Olson",
    "email": "technoweenie@gmail.com",
    "url": "http://techno-weenie.net"
  },
  "contributors": [
    {
      "name": "Sean McDaniel",
      "email": "sean.mcdaniel@me.com"
    }
  ],
  "main": "./lib/index",
  "directories": {
    "lib": "./lib"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/technoweenie/coffee-resque.git"
  },
  "dependencies": {
    "redis": ">= 0.5.2"
  },
  "engines": {
    "node": ">= 0.2.6"
  },
  "readme": "# Coffee-Resque\n\nCoffeescript/Node.js port of Resque.\n\n## USAGE\n\nFirst, you'll want to queue some jobs in your app:\n\n```javascript\nvar resque = require('coffee-resque').connect({\n  host: redisHost,\n  port: redisPort\n});\nresque.enqueue('math', 'add', [1,2]);\n```\n\nNext, you'll want to setup a worker to handle these jobs.   \n\nUpon completion of the job, invoke the passed callback with a result \n(if a result was produced by the job) or an `Error` (if an error was\nencountered).  If an `Error` is received, resque fails the\njob. In all other cases resque assumes the job is successful.\n\nThe callback is importantâ€”it notifies resque that the worker\nhas completed the current job and is ready for another. Neglecting to \ninvoke the callback will result in worker starvation.\n\n```javascript\n// implement your job functions.\nvar myJobs = {\n  add: function(a, b, callback) { callback(a + b); },\n  succeed: function(arg, callback) { callback(); },\n  fail: function(arg, callback) { callback(new Error('fail')); }\n}\n\n// setup a worker\nvar worker = require('coffee-resque').connect({\n  host: redisHost,\n  port: redisPort\n}).worker('*', myJobs)\n\n// some global event listeners\n//\n// Triggered every time the Worker polls.\nworker.on('poll', function(worker, queue) {})\n\n// Triggered before a Job is attempted.\nworker.on('job', function(worker, queue, job) {})\n\n// Triggered every time a Job errors.\nworker.on('error', function(err, worker, queue, job) {})\n\n// Triggered on every successful Job run.\nworker.on('success', function(worker, queue, job, result) {})\n\nworker.start()\n```\n\n## Development\n\nAll code is written in Coffee Script and converted to javascript as it's\npublished to npm.\n\nFor normal development, all you need to be concerned about is testing:\n\n```bash\n$ make test\n```\n\nIf you need to generate javascript for production purposes and don't want to use npm packages, you can use:\n\n```bash\n$ make generate-js\n$ make remove-js\n```\n\nYou can also have coffeescript watch the `src` directory and generate Javascript files as they're updated.\n\n```bash\n$ make dev\n```\n\n## TODO\n\n* Generic failure handling\n* Better polling",
  "_id": "coffee-resque@0.1.8",
  "dist": {
    "shasum": "e9dc65d449f8025befc749b4dd377d69ce482c08"
  },
  "_from": "coffee-resque"
}
